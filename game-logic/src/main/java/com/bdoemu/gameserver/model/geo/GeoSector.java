package com.bdoemu.gameserver.model.geo;

import com.bdoemu.gameserver.model.world.Location;
import com.bdoemu.jme3.collision.Collidable;
import com.bdoemu.jme3.collision.CollisionResult;
import com.bdoemu.jme3.collision.CollisionResults;
import com.bdoemu.jme3.math.Ray;
import com.bdoemu.jme3.math.Vector3f;
import com.bdoemu.jme3.scene.Mesh;

import java.util.HashMap;
import java.util.Map;

/**
 * Rewritten old GeoSector system and have improved new one.
 * I am expecting much better generation and detection of the meshes.
 * @author H1X4
 */
public class GeoSector {
    private static final Vector3f VECTOR_DOWN = new Vector3f(0.0f, 0.0f, -10.0f);
    private final int _regionX;
    private final int _regionY;
    private Map<Integer, Mesh> _meshes;

    /**
     * Default constructor for GeoSector.
     * @param regionX Region Location X.
     * @param regionY Region Location Y.
     */
    public GeoSector(int regionX, int regionY) {
        _meshes = new HashMap<>();
        _regionX = regionX;
        _regionY = regionY;
    }

    /**
     * Adds a collision based on region Z.
     * @param vertices Mesh Vertices.
     * @param indexes Mesh Indices.
     * @param regionZ Region Location Z.
     */
    public void attachCollision(final float[] vertices, final int[] indexes, final int regionZ) {
        _meshes.put(regionZ, new Mesh(vertices, indexes));
    }

    /**
     * Validates Z coordinate with a mesh. It is used to check if monster is able to move to
     * specified location or it will be delayed to not move.
     * @param x Creature Position X.
     * @param y Creature Position Y.
     * @param z Creature Position Z.
     * @return Corrected Z coordinate.
     */
    public double validateZ(double x, double y, double z) {
        final Vector3f pos = new Vector3f((float) x, (float) y, (float) z + 100.0f);
        final Ray ray = new Ray(pos, VECTOR_DOWN);
        final CollisionResults results = new CollisionResults();
        final int numCollisions = this.collideWith(ray, results);
        if (numCollisions > 0) {
            final CollisionResult hit = results.getClosestCollision();
            return hit.getContactPoint().getZ() + 5.0f;
        }
        return z;
    }

    /**
     * Validates if a creature is permitted to move to the specified coordinates.
     * Usually it will allow you to check for any insecurities generated by the engine.
     * @param x Creature Position X.
     * @param y Creature Position Y.
     * @param z Creature Position Z.
     * @return true if can move, otherwise false.
     */
    public boolean canMoveToZ(double x, double y, double z) {
        Vector3f destination = new Vector3f((float) x, (float) y, (float) z);
        Ray ray = new Ray(destination, VECTOR_DOWN);
        CollisionResults results = new CollisionResults();
        return collideWith(ray, results) <= 1;
    }

    /**
     * Checks if a character is visible within the collision map.
     * @param actorLoc Actor location
     * @param targetLoc Target location
     * @param actorBodyHeight Actor body height
     * @param targetBodyHeight Target body height
     * @return true if visible, otherwise false.
     */
    @SuppressWarnings("ConstantConditions")
    public boolean canSee(Location actorLoc, Location targetLoc, int actorBodyHeight, int targetBodyHeight) {
        final Vector3f pos = new Vector3f((float) actorLoc.getX(), (float) actorLoc.getY(), (float) actorLoc.getZ() + actorBodyHeight);
        final Vector3f dir = new Vector3f((float) targetLoc.getX(), (float) targetLoc.getY(), (float) targetLoc.getZ() + targetBodyHeight);
        final float distance = pos.distance(dir);
        dir.normalizeLocal().subtractLocal(pos).normalizeLocal();
        final Ray ray = new Ray(pos, dir);
        ray.setLimit(distance);
        final int numCollisions = collideWith(ray, new CollisionResults());
        return numCollisions == 0;
    }

    /**
     * Collides with another mesh.
     * @param other Collision ray
     * @param results Collision results
     * @return Total meshes it has colided with.
     */
    private int collideWith(final Collidable other, final CollisionResults results) {
        int total = 0;
        for (final Mesh child : _meshes.values())
            total += child.collideWith(other, results);
        return total;
    }

    /**
     * Returns the current geo sector region X coordinate.
     * @return Region X coordinate.
     */
    public int getRegionX() {
        return _regionX;
    }

    /**
     * Returns the current geo sector Y coordinate.
     * @return Region Y coordinate.
     */
    public int getRegionY() {
        return _regionY;
    }
}
